# 6-2. 데이터베이스 이용

<p> <a href="./study_dasp.html">DASP</a> </p>

**<p> 6. 데이터베이스 설계와 이용</p>**
<p> <a href="./study_0105.html">0105. 6-1. 데이터베이스 설계</a> </p>
<p> <a href="./study_0106.html">0106. 6-2. 데이터베이스 이용</a> </p>
<p> <a href="./study_0107.html">0107. 6-3. 데이터베이스 성능 개선</a> </p>

<br>

### **가. 데이터베이스 관리 시스템(DBMS)** 

데이터베이스가 이렇게 생겼어요

<br>

개념적 DBMS 아키텍처
- 데이터베이스(데이터,임시,시스템,로그) + 인스턴스(메모리,프로세스)

시작과 종료
- 시작 : 인스턴스 시작, 데이터베이스 마운트(DB는 관리자만 접근, 특정 유지 관리 가능), 데이터베이스 열기
- 종료 : 데이터베이스 닫기, 마운트 해제, 인스턴스 종료

데이터베이스 구조
- 데이터 사전 : 데이터베이스 형상을 관리하는 중요한 정보
- 데이터베이스, 테이블스페이스 데이터 파일
- 데이터 블록, 확장 영역 및 세그먼트
  - 블록
  - 확장 영역 : 연속된 블록, 삭제되어도 영역 반환하지 않음
  - 세그먼트

메모리 구조
- 데이터베이스 버퍼
- 로그 버퍼
- 공유 풀
- 정렬 영역

프로세스 구조
- 사용자 프로세스
- 서버 프로세스 : 사용자 프로세스와 통신
- 백그라운드 프로세스 : 데이터베이스 동작하기 위한 프로세스
  - PMON(프로세스), SMON(고장복구.정리), DBWn(기록), CKPT(체크포인트), LGWR(로그) 
  
<br>


### **나. 데이터 액세스** 

아래 방식으로 데이터에 접근할 수 있어요

<br>

실행 구조
- 사용자 요청
- 문법적 오류 확인 및 옵티마이저가 최적의 실행계획 찾음
- 실행하고 결과 전달
- 옵티마이저 : 통계정보를 활용하여 비용 측정(CBO), 정해진 우선 순위(RBO)
- 파싱 -> 옵티마이저 -> 로우 소스 생성 -> SQL 실행

명령어
- DDL : 암시적 commit, truncate 속도 빠른 대신 롤백 불가, 권한 grant/revoke 등
- DML : 커서 생성 -> 구문 분석 -> 질의결과설명(S) -> 질의결과출력정의(S) -> 변수바인드 -> 병렬화(가능할때) -> 실행 -> 질의로우인출(S) -> 커서닫기
- 제어 명령어 : 단순 명령 or 저장 프로시저

저장 프로시저
- 절차적인 언어 보완
- 긴 프로시저 작성하지 않는다

트리거
- 암시적으로 실행되는 구조
- 프로시저는 명시적으로 실행되는 것과 차이 있음
- 영향받는 행 수와 상관없이 1번만 수행됨
- before, after
- 보통 Insert, Update, Delete시 수행되나, DBMS에 따라 다른 것에서도 가능

<br>


### **다. 트랜잭션** 

논리적인 작업 단위인 트랜잭션

<br>

트랜잭션 : 논리적인 작업 단위
- 전체 성공하면 Commit, 아니면 Rollback

특성
- 원자성 : 전체를 수행하거나 수행하지 않거나
- 일관성 유지
- 고립성 : 트랜잭션이 종료전까지 갱신된 값이 안 보임
- 영속성 : 변경된 이후 어떠한 고장에도 손실되지 않음

병행제어
- 갱신 분실 문제(Lost Update Problem), 모순적인 판독 문제(Inconsistent Read Problem 또는 Dirty Read)
- Lock : 암시적인 또는 명시적인 잠금 실시
- 잠김단위 : 데이터베이스, 테이블, 페이지, 로우 단위
- Exclusive Lock(전용잠김 : 접근불가) vs Shared Lock(공용잠김 : Read only)
- 2PC
- 교착상태 : 무한대기상태 (4가지 필수 조건)
  - 상호배제 : 동시 사용 불가
  - 점유와 대기 : 한 쪽 사용, 다른 쪽 대기
  - 비중단 : 자원을 강제로 빼앗기지 않는다
  - 환형 대기 : 환형 사슬 존재

고장회복 : 장애시, 로그를 사용하여 before image로 UNDO를 실시하여 Rollback 처리한다

잠김 지속 시간 : Locking Duration Time 최소화

<br>


### **라. 백업 및 복구** 

안정적인 데이터베이스 관리가 필요해요

<br>

장애 유형
- 사용자 실수 : 실수로 테이블 삭제 등
- 미디어 장애 : CPU, 메모리, 디스크 장애
- 구문 장애 : 프로그램 오류, 용량 부족 등
- 사용자 프로세스 장애 : 비정상 종류, 네트워크 오류 등
- 인스턴스 장애 : 서버 프로세스 종료 (하드웨어 장애, 정전 등)

로그 파일
- 로그파일 기록 : 트랜잭션 시작시점, 데이 ???
- 로그파일 내용 : 트랜잭션 식별자, 레코드, 데이터 식별자, 변경전후 이미지

데이터베이스 복구 알고리즘
- 동기적 갱신 vs 비동기적 갱신 : 트랜잭션 실행이후 버퍼 내용(메모리)을 저장 매체(디스크)에 동기적으로 저장하는지 여부
- NO-UNDO / REDO : 비동기적 갱신으로 저장매체 저장되기 전에 장애시, 재실행필요
- UNDO / NO-REDO : 동기적 갱신으로 재실행 필요는 없으나, 트랜잭션 중인 것은 취소해야만 함
- UNDO / REDO
- NO-UNDO / NO-REDO

백업 종류
- OS를 이용한 물리 백업과 유틸리티를 이용한 논리 백업

데이터베이스 백업 가이드 라인
- 정기적인 풀백업
- 변화가 생긴 전후 백업
  - 데이블스페이스 추가, 데이터파일 추가, 로그 파일 변경, 백업파일 2본 이상
  - 아카이브 모드 전환시 컨트롤 파일 백업, 노 아카이브 모드 전환시 전체 백업
  - 논리 백업은 특정 데이터, 테이블 복구 용이
  - 분산 DB는 동일 모드로 백업, 읽기전용 테이블스페이스는 온라인 백업 불필요

