<h1 id="2장-벡터">2장 벡터</h1>
<p><strong>mode : 변수의 종류</strong></p>
<p><strong>type : 변수를 좀 더 상세하게 구분</strong></p>
<p><strong>integer와 double은 모두 mode는 numeric임</strong></p>
<p>x ← 8</p>
<p>y ← c(1,2)</p>
<p>z ← integer()</p>
<p>mode(x)</p>
<p>typeof(x)</p>
<p>mode(y)</p>
<p>typeof(y)</p>
<p>mode(z)</p>
<p>typeof(z)</p>
<p><strong>벡터의 길이 : 갯수</strong></p>
<p>length(y)</p>
<p><strong>행렬과 배열은 벡트처럼 사용할 수 있다.</strong></p>
<p>**선언부가 필요하지는 않다. 단 벡터의 경우에는 **</p>
<p>y[3] ← 3  # 위에서 정의한 y가 있어서 길이가 2에서 3으로 늘어남</p>
<p>k[1] ← 1  # k가 정의되어 있지 않기 때문에 에러 발생</p>
<p><strong>변수 타입은 실시간으로 변할 수 있다</strong></p>
<p><strong>주의해서 사용하지 않으면 원하지 않은 결과를 낳을 수 있다</strong></p>
<p>m ← 1</p>
<p>typeof(m)</p>
<p>m ← &quot;1&quot;</p>
<p>typeof(m)</p>
<p><strong>벡터 길이가 다른 두 변수를 연산하면 재사용하여 긴 쪽 길이에 맞춘다</strong></p>
<p><strong>짧은 쪽은 재사용하여 긴 쪽 깉이와 같은 길이로 만들어진다</strong></p>
<p>x ← c(1,2,3,4) + c(1,2)</p>
<p>x</p>
<p>x ← c(1,2,3,4,5) + c(1,2)  # 배수가 안되니깐, 에러 발생 (5개와 2개)</p>
<h1 id="mode--변수의-종류">mode : 변수의 종류</h1>
<h1 id="type--변수를-좀-더-상세하게-구분">type : 변수를 좀 더 상세하게 구분</h1>
<h1 id="integer와-double은-모두-mode는-numeric임">integer와 double은 모두 mode는 numeric임</h1>
<p>x ← 8</p>
<p>y ← c(1,2)</p>
<p>z ← integer()</p>
<p>mode(x)</p>
<p>typeof(x)</p>
<p>mode(y)</p>
<p>typeof(y)</p>
<p>mode(z)</p>
<p>typeof(z)</p>
<h1 id="벡터의-길이--갯수">벡터의 길이 : 갯수</h1>
<p>length(y)</p>
<h1 id="행렬과-배열은-벡트처럼-사용할-수-있다">행렬과 배열은 벡트처럼 사용할 수 있다.</h1>
<h1 id="선언부가-필요하지는-않다-단-벡터의-경우에는">선언부가 필요하지는 않다. 단 벡터의 경우에는</h1>
<p>y[3] ← 3  # 위에서 정의한 y가 있어서 길이가 2에서 3으로 늘어남</p>
<p>k[1] ← 1  # k가 정의되어 있지 않기 때문에 에러 발생</p>
<h1 id="변수-타입은-실시간으로-변할-수-있다">변수 타입은 실시간으로 변할 수 있다</h1>
<h1 id="주의해서-사용하지-않으면-원하지-않은-결과를-낳을-수-있다">주의해서 사용하지 않으면 원하지 않은 결과를 낳을 수 있다</h1>
<p>m ← 1</p>
<p>typeof(m)</p>
<p>m ← &quot;1&quot;</p>
<p>typeof(m)</p>
<h1 id="벡터-길이가-다른-두-변수를-연산하면-재사용하여-긴-쪽-길이에-맞춘다">벡터 길이가 다른 두 변수를 연산하면 재사용하여 긴 쪽 길이에 맞춘다</h1>
<h1 id="짧은-쪽은-재사용하여-긴-쪽-깉이와-같은-길이로-만들어진다">짧은 쪽은 재사용하여 긴 쪽 깉이와 같은 길이로 만들어진다</h1>
<p>x ← c(1,2,3,4) + c(1,2)</p>
<p>x</p>
<p>x ← c(1,2,3,4,5) + c(1,2)  # 배수가 안되니깐, 에러 발생 (5개와 2개)</p>
<h1 id="mode--변수의-종류-1">mode : 변수의 종류</h1>
<h1 id="type--변수를-좀-더-상세하게-구분-1">type : 변수를 좀 더 상세하게 구분</h1>
<h1 id="integer와-double은-모두-mode는-numeric임-1">integer와 double은 모두 mode는 numeric임</h1>
<p>x ← 8</p>
<p>y ← c(1,2)</p>
<p>z ← integer()</p>
<p>mode(x)</p>
<p>typeof(x)</p>
<p>mode(y)</p>
<p>typeof(y)</p>
<p>mode(z)</p>
<p>typeof(z)</p>
<h1 id="벡터의-길이--갯수-1">벡터의 길이 : 갯수</h1>
<p>length(y)</p>
<h1 id="행렬과-배열은-벡트처럼-사용할-수-있다-1">행렬과 배열은 벡트처럼 사용할 수 있다.</h1>
<h1 id="선언부가-필요하지는-않다-단-벡터의-경우에는-1">선언부가 필요하지는 않다. 단 벡터의 경우에는</h1>
<p>y[3] ← 3  # 위에서 정의한 y가 있어서 길이가 2에서 3으로 늘어남</p>
<p>k[1] ← 1  # k가 정의되어 있지 않기 때문에 에러 발생</p>
<h1 id="변수-타입은-실시간으로-변할-수-있다-1">변수 타입은 실시간으로 변할 수 있다</h1>
<h1 id="주의해서-사용하지-않으면-원하지-않은-결과를-낳을-수-있다-1">주의해서 사용하지 않으면 원하지 않은 결과를 낳을 수 있다</h1>
<p>m ← 1</p>
<p>typeof(m)</p>
<p>m ← &quot;1&quot;</p>
<p>typeof(m)</p>
<h1 id="벡터-길이가-다른-두-변수를-연산하면-재사용하여-긴-쪽-길이에-맞춘다-1">벡터 길이가 다른 두 변수를 연산하면 재사용하여 긴 쪽 길이에 맞춘다</h1>
<h1 id="짧은-쪽은-재사용하여-긴-쪽-깉이와-같은-길이로-만들어진다-1">짧은 쪽은 재사용하여 긴 쪽 깉이와 같은 길이로 만들어진다</h1>
<p>x ← c(1,2,3,4) + c(1,2)</p>
<p>x</p>
<p>x ← c(1,2,3,4,5) + c(1,2)  # 배수가 안되니깐, 에러 발생 (5개와 2개)</p>
<p><strong>벡터 인덱싱</strong></p>
<p>x ← c(1,3,5,7,9)</p>
<p>x[c(2,2,3)]</p>
<p>x[2:4]</p>
<p>x[-1]</p>
<p>x[-length(x)]</p>
<p>x[3:2]</p>
<p>x[1:0]</p>
<p>x[0]</p>
<p>2:4</p>
<p>5:3</p>
<p>seq(from=12, to=20, by=2)  # 모든 값을 생략할 수도 있다</p>
<p>rep()  # 동일한 숫자 반복</p>
<p><strong>all, any  : 모두가 만족하거나, 하나라도 만족하거나</strong></p>
<p>all(x&gt;4)</p>
<p>any(x&gt;4)</p>
<p><strong>벡터화 연산</strong></p>
<p><strong>두 벡터끼리 연산을 수행, 각 벡터의 단위값끼리</strong></p>
<p>c(1,2)+3</p>
<p><strong>함수에서 스칼라 값이 들어오기를 원하다면 꼭 확인을 해야한다</strong></p>
<p>if (length(x) != 1) stop('vector x is not allowed')</p>
<p><strong>NA : 누락된 값 (존재하지만 불확실한 값)</strong></p>
<p><strong>NULL : 값이 없는 것 : Null은 어떤 형식도 취하지 않는 특별한 객체</strong></p>
<p>x ← integer()</p>
<p>x ← c(x,1)</p>
<p>x ← NULL</p>
<p>x ← c(x,1)</p>
<p>x ← NA</p>
<p>x ← c(x,1)  # NA 값을 제거해 줘야 함</p>
<p>mean(x, na.rm = T)</p>
<p><strong>필터링</strong></p>
<p>z ← c(5,2,-3,8)</p>
<p>w ← z[z<em>z &gt; 8]    # &quot;z</em>z &gt; 8&quot;은 boolean값을 가짐</p>
<p>w</p>
<p><strong>필터링을 통해서는 NA가 잘 안 걸러짐</strong></p>
<p>subset(z,z&gt;3)</p>
<p><strong>해당 조건의 위치만 찾고 싶을 때 : which</strong></p>
<p>which(z*z &gt; 8)</p>
<p><strong>벡터화된 조건문 : ifelse()</strong></p>
<p>x ← 1:10</p>
<p>y ← ifelse(x %% 2 == 0, 0, 11)</p>
<p>y</p>
<p><strong>벡터 동일성 테스트</strong></p>
<p>x ← c(1,2,4)</p>
<p>y ← 1:3</p>
<p>x == y</p>
<p>all(x==y)</p>
<p>x ← 1:2</p>
<p>y ← c(1,2)</p>
<p>identical(x,y)  # type까지 확인</p>
<p><strong>벡터 원소에 이름을</strong></p>
<p>x ← c(1,2,4)</p>
<p>names(x)</p>
<p>x</p>
<p>names(x) ← c(&quot;a&quot;,&quot;b&quot;,&quot;ab&quot;)</p>
<p>names(x)</p>
<p>x</p>
<p>x[&quot;b&quot;]</p>
<p>x ← c(1,3,5,7,9)</p>
<p>x[c(2,2,3)]</p>
<p>x[2:4]</p>
<p>x[-1]</p>
<p>x[-length(x)]</p>
<p>x[3:2]</p>
<p>x[1:0]</p>
<p>x[0]</p>
<p>2:4</p>
<p>5:3</p>
<p>seq(from=12, to=20, by=2)  # 모든 값을 생략할 수도 있다</p>
<p>rep()  # 동일한 숫자 반복</p>
<p><strong>all, any  : 모두가 만족하거나, 하나라도 만족하거나</strong></p>
<p>all(x&gt;4)</p>
<p>any(x&gt;4)</p>
<p><strong>벡터화 연산</strong></p>
<p><strong>두 벡터끼리 연산을 수행, 각 벡터의 단위값끼리</strong></p>
<p>c(1,2)+3</p>
<p><strong>함수에서 스칼라 값이 들어오기를 원하다면 꼭 확인을 해야한다</strong></p>
<p>if (length(x) != 1) stop('vector x is not allowed')</p>
<p><strong>NA : 누락된 값 (존재하지만 불확실한 값)</strong></p>
<p><strong>NULL : 값이 없는 것 : Null은 어떤 형식도 취하지 않는 특별한 객체</strong></p>
<p>x ← integer()</p>
<p>x ← c(x,1)</p>
<p>x ← NULL</p>
<p>x ← c(x,1)</p>
<p>x ← NA</p>
<p>x ← c(x,1)  # NA 값을 제거해 줘야 함</p>
<p>mean(x, na.rm = T)</p>
<p><strong>필터링</strong></p>
<p>z ← c(5,2,-3,8)</p>
<p>w ← z[z<em>z &gt; 8]    # &quot;z</em>z &gt; 8&quot;은 boolean값을 가짐</p>
<p>w</p>
<p><strong>필터링을 통해서는 NA가 잘 안 걸러짐</strong></p>
<p>subset(z,z&gt;3)</p>
<p><strong>해당 조건의 위치만 찾고 싶을 때 : which</strong></p>
<p>which(z*z &gt; 8)</p>
<p><strong>벡터화된 조건문 : ifelse()</strong></p>
<p>x ← 1:10</p>
<p>y ← ifelse(x %% 2 == 0, 0, 11)</p>
<p>y</p>
<p><strong>벡터 동일성 테스트</strong></p>
<p>x ← c(1,2,4)</p>
<p>y ← 1:3</p>
<p>x == y</p>
<p>all(x==y)</p>
<p>x ← 1:2</p>
<p>y ← c(1,2)</p>
<p>identical(x,y)  # type까지 확인</p>
<p><strong>벡터 원소에 이름을</strong></p>
<p>x ← c(1,2,4)</p>
<p>names(x)</p>
<p>x</p>
<p>names(x) ← c(&quot;a&quot;,&quot;b&quot;,&quot;ab&quot;)</p>
<p>names(x)</p>
<p>x</p>
<p>x[&quot;b&quot;]</p>
<p>x ← c(1,3,5,7,9)</p>
<p>x[c(2,2,3)]</p>
<p>x[2:4]</p>
<p>x[-1]</p>
<p>x[-length(x)]</p>
<p>x[3:2]</p>
<p>x[1:0]</p>
<p>x[0]</p>
<p>2:4</p>
<p>5:3</p>
<p>seq(from=12, to=20, by=2)  # 모든 값을 생략할 수도 있다</p>
<p>rep()  # 동일한 숫자 반복</p>
<p><strong>all, any  : 모두가 만족하거나, 하나라도 만족하거나</strong></p>
<p>all(x&gt;4)</p>
<p>any(x&gt;4)</p>
<p><strong>벡터화 연산</strong></p>
<p><strong>두 벡터끼리 연산을 수행, 각 벡터의 단위값끼리</strong></p>
<p>c(1,2)+3</p>
<p><strong>함수에서 스칼라 값이 들어오기를 원하다면 꼭 확인을 해야한다</strong></p>
<p>if (length(x) != 1) stop('vector x is not allowed')</p>
<p><strong>NA : 누락된 값 (존재하지만 불확실한 값)</strong></p>
<p><strong>NULL : 값이 없는 것 : Null은 어떤 형식도 취하지 않는 특별한 객체</strong></p>
<p>x ← integer()</p>
<p>x ← c(x,1)</p>
<p>x ← NULL</p>
<p>x ← c(x,1)</p>
<p>x ← NA</p>
<p>x ← c(x,1)  # NA 값을 제거해 줘야 함</p>
<p>mean(x, na.rm = T)</p>
<p><strong>필터링</strong></p>
<p>z ← c(5,2,-3,8)</p>
<p>w ← z[z<em>z &gt; 8]    # &quot;z</em>z &gt; 8&quot;은 boolean값을 가짐</p>
<p>w</p>
<p><strong>필터링을 통해서는 NA가 잘 안 걸러짐</strong></p>
<p>subset(z,z&gt;3)</p>
<p><strong>해당 조건의 위치만 찾고 싶을 때 : which</strong></p>
<p>which(z*z &gt; 8)</p>
<p><strong>벡터화된 조건문 : ifelse()</strong></p>
<p>x ← 1:10</p>
<p>y ← ifelse(x %% 2 == 0, 0, 11)</p>
<p>y</p>
<p><strong>벡터 동일성 테스트</strong></p>
<p>x ← c(1,2,4)</p>
<p>y ← 1:3</p>
<p>x == y</p>
<p>all(x==y)</p>
<p>x ← 1:2</p>
<p>y ← c(1,2)</p>
<p>identical(x,y)  # type까지 확인</p>
<p><strong>벡터 원소에 이름을</strong></p>
<p>x ← c(1,2,4)</p>
<p>names(x)</p>
<p>x</p>
<p>names(x) ← c(&quot;a&quot;,&quot;b&quot;,&quot;ab&quot;)</p>
<p>names(x)</p>
<p>x</p>
<p>x[&quot;b&quot;]</p>
