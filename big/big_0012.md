# 2장 벡터

**mode : 변수의 종류**

**type : 변수를 좀 더 상세하게 구분**

**integer와 double은 모두 mode는 numeric임**

x <- 8

y <- c(1,2)

z <- integer()

mode(x)

typeof(x)

mode(y)

typeof(y)

mode(z)

typeof(z)

**벡터의 길이 : 갯수**

length(y)

**행렬과 배열은 벡트처럼 사용할 수 있다.**

**선언부가 필요하지는 않다. 단 벡터의 경우에는 **

y[3] <- 3  # 위에서 정의한 y가 있어서 길이가 2에서 3으로 늘어남

k[1] <- 1  # k가 정의되어 있지 않기 때문에 에러 발생 



**변수 타입은 실시간으로 변할 수 있다**

**주의해서 사용하지 않으면 원하지 않은 결과를 낳을 수 있다**

m <- 1

typeof(m)

m <- "1"

typeof(m)



**벡터 길이가 다른 두 변수를 연산하면 재사용하여 긴 쪽 길이에 맞춘다**

**짧은 쪽은 재사용하여 긴 쪽 깉이와 같은 길이로 만들어진다**

x <- c(1,2,3,4) + c(1,2)

x



x <- c(1,2,3,4,5) + c(1,2)  # 배수가 안되니깐, 에러 발생 (5개와 2개)



# mode : 변수의 종류

# type : 변수를 좀 더 상세하게 구분

# integer와 double은 모두 mode는 numeric임

x <- 8

y <- c(1,2)

z <- integer()

mode(x)

typeof(x)

mode(y)

typeof(y)

mode(z)

typeof(z)



# 벡터의 길이 : 갯수

length(y)



# 행렬과 배열은 벡트처럼 사용할 수 있다.



# 선언부가 필요하지는 않다. 단 벡터의 경우에는 

y[3] <- 3  # 위에서 정의한 y가 있어서 길이가 2에서 3으로 늘어남

k[1] <- 1  # k가 정의되어 있지 않기 때문에 에러 발생 



# 변수 타입은 실시간으로 변할 수 있다

# 주의해서 사용하지 않으면 원하지 않은 결과를 낳을 수 있다

m <- 1

typeof(m)

m <- "1"

typeof(m)



# 벡터 길이가 다른 두 변수를 연산하면 재사용하여 긴 쪽 길이에 맞춘다

# 짧은 쪽은 재사용하여 긴 쪽 깉이와 같은 길이로 만들어진다

x <- c(1,2,3,4) + c(1,2)

x



x <- c(1,2,3,4,5) + c(1,2)  # 배수가 안되니깐, 에러 발생 (5개와 2개)



# mode : 변수의 종류

# type : 변수를 좀 더 상세하게 구분

# integer와 double은 모두 mode는 numeric임

x <- 8

y <- c(1,2)

z <- integer()

mode(x)

typeof(x)

mode(y)

typeof(y)

mode(z)

typeof(z)



# 벡터의 길이 : 갯수

length(y)



# 행렬과 배열은 벡트처럼 사용할 수 있다.



# 선언부가 필요하지는 않다. 단 벡터의 경우에는 

y[3] <- 3  # 위에서 정의한 y가 있어서 길이가 2에서 3으로 늘어남

k[1] <- 1  # k가 정의되어 있지 않기 때문에 에러 발생 



# 변수 타입은 실시간으로 변할 수 있다

# 주의해서 사용하지 않으면 원하지 않은 결과를 낳을 수 있다

m <- 1

typeof(m)

m <- "1"

typeof(m)



# 벡터 길이가 다른 두 변수를 연산하면 재사용하여 긴 쪽 길이에 맞춘다

# 짧은 쪽은 재사용하여 긴 쪽 깉이와 같은 길이로 만들어진다

x <- c(1,2,3,4) + c(1,2)

x



x <- c(1,2,3,4,5) + c(1,2)  # 배수가 안되니깐, 에러 발생 (5개와 2개)



**벡터 인덱싱**

x <- c(1,3,5,7,9)

x[c(2,2,3)]

x[2:4]

x[-1]

x[-length(x)]

x[3:2]

x[1:0]

x[0]



2:4

5:3

seq(from=12, to=20, by=2)  # 모든 값을 생략할 수도 있다 

rep()  # 동일한 숫자 반복



**all, any  : 모두가 만족하거나, 하나라도 만족하거나**

all(x>4)

any(x>4)



**벡터화 연산**

**두 벡터끼리 연산을 수행, 각 벡터의 단위값끼리**

c(1,2)+3

**함수에서 스칼라 값이 들어오기를 원하다면 꼭 확인을 해야한다**

if (length(x) != 1) stop('vector x is not allowed')



**NA : 누락된 값 (존재하지만 불확실한 값)**

**NULL : 값이 없는 것 : Null은 어떤 형식도 취하지 않는 특별한 객체**

x <- integer()

x <- c(x,1)

x <- NULL

x <- c(x,1)

x <- NA

x <- c(x,1)  # NA 값을 제거해 줘야 함

mean(x, na.rm = T)



**필터링**

z <- c(5,2,-3,8)

w <- z[z*z > 8]    # "z*z > 8"은 boolean값을 가짐

w

**필터링을 통해서는 NA가 잘 안 걸러짐**

subset(z,z>3)

**해당 조건의 위치만 찾고 싶을 때 : which**

which(z*z > 8)



**벡터화된 조건문 : ifelse()**

x <- 1:10

y <- ifelse(x %% 2 == 0, 0, 11)

y



**벡터 동일성 테스트**

x <- c(1,2,4)

y <- 1:3

x == y

all(x==y)



x <- 1:2

y <- c(1,2)

identical(x,y)  # type까지 확인



**벡터 원소에 이름을**

x <- c(1,2,4)

names(x)

x

names(x) <- c("a","b","ab")

names(x)

x

x["b"]

x <- c(1,3,5,7,9)

x[c(2,2,3)]

x[2:4]

x[-1]

x[-length(x)]

x[3:2]

x[1:0]

x[0]



2:4

5:3

seq(from=12, to=20, by=2)  # 모든 값을 생략할 수도 있다 

rep()  # 동일한 숫자 반복



**all, any  : 모두가 만족하거나, 하나라도 만족하거나**

all(x>4)

any(x>4)



**벡터화 연산**

**두 벡터끼리 연산을 수행, 각 벡터의 단위값끼리**

c(1,2)+3

**함수에서 스칼라 값이 들어오기를 원하다면 꼭 확인을 해야한다**

if (length(x) != 1) stop('vector x is not allowed')



**NA : 누락된 값 (존재하지만 불확실한 값)**

**NULL : 값이 없는 것 : Null은 어떤 형식도 취하지 않는 특별한 객체**

x <- integer()

x <- c(x,1)

x <- NULL

x <- c(x,1)

x <- NA

x <- c(x,1)  # NA 값을 제거해 줘야 함

mean(x, na.rm = T)



**필터링**

z <- c(5,2,-3,8)

w <- z[z*z > 8]    # "z*z > 8"은 boolean값을 가짐

w

**필터링을 통해서는 NA가 잘 안 걸러짐**

subset(z,z>3)

**해당 조건의 위치만 찾고 싶을 때 : which**

which(z*z > 8)



**벡터화된 조건문 : ifelse()**

x <- 1:10

y <- ifelse(x %% 2 == 0, 0, 11)

y



**벡터 동일성 테스트**

x <- c(1,2,4)

y <- 1:3

x == y

all(x==y)



x <- 1:2

y <- c(1,2)

identical(x,y)  # type까지 확인



**벡터 원소에 이름을**

x <- c(1,2,4)

names(x)

x

names(x) <- c("a","b","ab")

names(x)

x

x["b"]

x <- c(1,3,5,7,9)

x[c(2,2,3)]

x[2:4]

x[-1]

x[-length(x)]

x[3:2]

x[1:0]

x[0]



2:4

5:3

seq(from=12, to=20, by=2)  # 모든 값을 생략할 수도 있다 

rep()  # 동일한 숫자 반복



**all, any  : 모두가 만족하거나, 하나라도 만족하거나**

all(x>4)

any(x>4)



**벡터화 연산**

**두 벡터끼리 연산을 수행, 각 벡터의 단위값끼리**

c(1,2)+3

**함수에서 스칼라 값이 들어오기를 원하다면 꼭 확인을 해야한다**

if (length(x) != 1) stop('vector x is not allowed')



**NA : 누락된 값 (존재하지만 불확실한 값)**

**NULL : 값이 없는 것 : Null은 어떤 형식도 취하지 않는 특별한 객체**

x <- integer()

x <- c(x,1)

x <- NULL

x <- c(x,1)

x <- NA

x <- c(x,1)  # NA 값을 제거해 줘야 함

mean(x, na.rm = T)



**필터링**

z <- c(5,2,-3,8)

w <- z[z*z > 8]    # "z*z > 8"은 boolean값을 가짐

w

**필터링을 통해서는 NA가 잘 안 걸러짐**

subset(z,z>3)

**해당 조건의 위치만 찾고 싶을 때 : which**

which(z*z > 8)



**벡터화된 조건문 : ifelse()**

x <- 1:10

y <- ifelse(x %% 2 == 0, 0, 11)

y



**벡터 동일성 테스트**

x <- c(1,2,4)

y <- 1:3

x == y

all(x==y)



x <- 1:2

y <- c(1,2)

identical(x,y)  # type까지 확인



**벡터 원소에 이름을**

x <- c(1,2,4)

names(x)

x

names(x) <- c("a","b","ab")

names(x)

x

x["b"]